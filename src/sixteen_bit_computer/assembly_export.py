def assembly_to_arduino():
    generate_arduino_header()
    generate_arduino_cpp()

def generate_arduino_header(progname):
    """

    Create arduino header file for the given assembly.

    The header file looks approximately like this::

        #ifndef PROG_PROGNAME_H
        #define PROG_PROGNAME_H

        #include "Arduino.h"

        extern const unsigned int num_progname_words;
        extern const unsigned int progname_addresses[];
        extern const unsigned int progname_words[];

        extern const char fibonacci_program_name[];

        #endif
    
    Args:
        progname (str): The name of the program, used to refer to it in
            the header and cpp files.

    Returns:
        str: String ready to be written to a file.
    """

    h_lines = []
    h_lines.append("#ifndef PROG_{progname}_H".format(
        progname=progname.upper()
    ))
    h_lines.append("#define PROG_{progname}_H".format(
        progname=progname.upper()
    ))
    h_lines.append("")
    h_lines.append("#include <Arduino.h>")
    h_lines.append("")
    h_lines.append("extern const unsigned int num_{progname}_words;".format(
        progname=progname
    ))
    h_lines.append("extern const unsigned int {progname}_addresses[];".format(
        progname=progname
    ))
    h_lines.append("extern const unsigned int {progname}_words;".format(
        progname=progname
    ))

    h_lines.append("")
    h_lines.append("extern const char {progname}_program_name[];".format(
        progname=progname
    ))
    h_lines.append("")
    h_lines.append("#endif")
    h_lines.append("")

    return "\n".join(h_lines)


def generate_arduino_cpp(assembly, progname, progname_short, h_filename):
    """
    Generate cpp file for program for Arduino.

    The cpp file looks like this::

        #include "prog_progname.h"

        // Number of words in the program
        extern const unsigned int num_progname_words = 13;

        // Address of each word in the list of machinecode words
        extern const unsigned int progname_addresses[] PROGMEM = {
            0xFF00, // 0x003D - 0001 SET A #0xC
            0xFF01, // 0x000C - 0001 
            0xFF02, // 0x002F - 0002 SET B #1
            0x00A1, // 0x0001 - 0002 
            0x00A2, // 0x0000 - 0003 NOOP
            0x00A3  // 0xFFFF - 0004 HALT
        };

        // Value for each machinecode word
        extern const unsigned int progname_words[] PROGMEM = {
            0x003D, // 0xFF00 - 0001 SET A #0x000C
            0x000C, // 0xFF01 - 0001 
            0x002F, // 0xFF02 - 0002 SET B #1
            0x0001, // 0x00A1 - 0002 
            0x0000, // 0x00A2 - 0003 NOOP
            0xFFFF  // 0x00A3 - 0004 HALT
        };

        // Max of seven characters
        extern const char progname_program_name[] = "Prgname";

    The values of the machinecode words are converted to thier unsigned
    equivalents during this process.
    """

    num_words = len(machinecode)
    address_lines, word_lines = get_address_and_word_lines(assembly)

    cpp_lines = []
    cpp_lines.append("#include \"{h_filename}\"".format(h_filename=h_filename))
    cpp_lines.append("")


    cpp_lines.append("Number of words in the program")
    cpp_lines.append(
        "extern const unsigned int num_{progname}_words "
        "= {progname};".format(
            progname=progname, num_words=num_words
        )
    )
    cpp_lines.append("")


    cpp_lines.append(
        "// Address of each word in the list of machinecode words."
    )
    cpp_lines.append(
        "extern const unsigned int {progname}_addresses[] "
        "PROGMEM = {{".format(progname=progname)
    )
    for line in address_lines:
        cpp_lines.append(line)
    cpp_lines.append("};")
    cpp_lines.append("")


    cpp_lines.append("// Value for each machinecode word.")
    cpp_lines.append(
        "extern const unsigned int {progname}_words[] "
        "PROGMEM = {{".format(progname=progname)
    )
    for line in word_lines:
        cpp_lines.append(line)
    cpp_lines.append("};")
    cpp_lines.append("")


    cpp_lines.append("// Max of seven characters")
    cpp_lines.append("extern const char {progname}_program_name[] = \"{progname_short}\";".format(
        progname=proname,
        progname_short=progname_short[:7]
    ))
    cpp_lines.append("")

    return "\n".join(cpp_lines)


def get_address_and_word_lines(assembly):
    """

    """
    machinecode = assembler.assembly_lines_to_dictionary(assembly)
    
    address_lines = []
    word_lines = []

    for line in assembly:
        for word, index in enumerate(line.pattern.machinecode):
            # Add line if it's the first machincode word generated by
            # this line
            if index == 0:
                line_part = " {line}".format(line.raw_line)
            else:
                line_part = ""

            # Generate string for address
            address_line = (
                "    0x{address:04X}, // 0x{word:04X} - {line_no:04} "
                "{line_part}"
            )
            address_line.format(
                address=word.index,
                word=number_utils.get_positive_equivalent(
                    word.value, bitwidth=16
                ),
                line_no=line.line_no,
                line_part=line_part
            )
            address_lines.append(address_line)

            # Generate string for word
            word_line = (
                "    0x{word:04X}, // 0x{address:04X} - {line_no:04} "
                "{line_part}"
            )
            word_line.format(
                word=number_utils.get_positive_equivalent(
                    word.value, bitwidth=16
                ),
                address=word.index,
                line_no=line.line_no,
                line_part=line_part
            )
            word_lines.append(word_line)

    # Remove commas from last line
    address_lines[-1][6] = " "
    word_lines[-1][6] = " "

    return address_lines, word_lines


def assembly_to_logisim():
    pass