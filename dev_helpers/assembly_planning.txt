// Define an alias
// This doesn't generate any machine code
!MY_ALIAS #123   

// Define a variable without setting any associated data
// This doesn't generate any machine code
$my_var #456

// Define some data
    "hello"
    #34
    #34 #34 #12

// Define some data and assign a variable to the first word
//
// The variable behaves like a label in this case, it sticks
// to the next bit of machinecode declared
$message1
    "foobar"

$some_data
    #32 #44 #55

// Anchor the next bit of machine code to a certain index
@ #100
$message
    "Winner!"


@#300
&start
    LOAD [#123] A
    SET A !MY_ALIAS
    JUMP_IF_ACC_GT !NUM_BOXES &some_label
    JUMP &start

&end
    STORE A [B]
    LOAD [$variable] ACC
    HALT

Tokens
    !<name> - Alias
    @<number> - Anchor
    &<name> - Label
    $<name> - Variable
    #<number> - Number
    "..." - Ascii
    // - Comments
    [...] - Memory ref
    name - pattern of alphanumerics
    number - Valid Python number 0xFFFA, 34, -14, 0o23
    Instruction - LOAD, NOOP, etc
    Module - A, B ACC, etc
    Constants - labels, variables, aliases, numbers

Aliases, variables and labels need to conform to sensible word patterns















$memloc_a 
$memloc_b #1
$memloc_c #1 #2 !CONST

% #0
&label_a
    LOAD #123 A
    SET A !CONST
&label_b
    STORE #123 $memloc_a
    JUMP @label



Tokens:
    Constant (!CONST)
    8 bit number (#123)
    16 bit bumber (##1865)
    Instruction (LOAD, ADD)
    Module (A, B)
    Anchor (% #123)
    memloc ($ball_pos_x)
    Label (%loop_start)


! @ # $ % & * ?






constant number
anchor number
memloc [number number ...]
label
intruction [module/number/memloc/anchor module/number]

token
    type
    value

assembly_line
    raw_line
    line_no
    tokens


build_const_map

resolve_consts

parse tokens
    Takes a line and determines if it's a:
        * Instruction (With placeholders for any constants, labels or variables)
        * Label
        * Anchor
        * Variable
        * Constant definition




def assemble
    for line in assembly_file:
        tokenised_lines.append(tokenise_line(line))


make a new assembly chunk for each @ anchor

Variable positions also need to be resolved reltive to thier anchor

%label_b can only be resolved once the instructions have been resolved to machine code bytes







Signatures are made up of:
    Instruction code: NOOP, ADD, JUMP
    Zero or more arguments: A, B, [C], #34, [#34], @label)

Instruction codes are unique identifiers

Arguments can be
    Module names: A, B, SP, PC, etc
    Constant: @label, $variable, #34
    Memory ref: [<module name>], [<constant>]

Memory refs can realised with module names or constants


MR(A)

MR(CONST)

CONST

A

NOOP

INS.NOOP, MEM.A, MOD.SP

INS.JUMP, MEM.CONST, CST.CST



signatures = {
    0: Sig(NOOP),
    1: None,
    2: None,
    3: Sig(LOAD, M(A), B),
    4: Sig(LOAD, M(CONST), ACC),
    5: Sig(JUMP, CONST),
    6: Sig(JUMP, M(CONST)),
}










def assemble():
    assembly_lines = []
    for line_no, line in lines:
        assembly_line = AssemblyLine(line)
        assembly_line.line_no = line_no
        assembly_lines.append(assembly_line)





def process_line():
    Lines can be:
        defines



rules - defines and variables must come before any assembly


tokens = tokenise_line()

patterns:
    assembly
    anchor
    data
    label
    variable (variable, or variable, immediate)
    alias_def (alias, constant)

    assembly - consult assembly list for valid assembly patterns



assembly_sig = 
    (LOAD, M(A), ACC)
    (JUMP, ALIAS("!my_alias"))
    (JUMP, CONST("#123"))

Consts can be:
    - Immediate values (#123)
    - Labels (&loop_start)
        Can only be resolved once we know how where the chunk starts, and
        how many words in the chunk
    - Aliases (!num_apples)
    - Variables ($my_var)


machinecode = signature_to_machinecode(assembly_sig)

for word in machinecode:
    if word.is_instruction_word:
        pass
    if word.is_data_word:
        if word.token.is_immediate:
            word.value = resolve_immediate(word.token)
        if word.token.is_alias:
            word.value = resolve_alias(word.token)
        if word.token.is_label:
            word.value = resolve_label(...)
        if word.token.is_variable:


class AssemblyLine():
    raw_line
    line_no
    pattern

class MachinecodeChunk():
    start
    words (can be data (e.g. ascii) or instructions (which also have data))
    length

class MachineCodeWord():
    label

    class MachineCodeInstructionWord

    class MachineCodeImmediateWord

    class MachineCodeVariableWord

    class MachineCodeAliasWord


def process_assembly_line(line):
    assembly_line = AssemblyLine()
    line = trim_comments(line)
    string_tokens = line.split()
    tokens = []
    for string_token in string_tokens:
        tokens.append(match_token(string_token))
    pattern = match_to_pattern(tokens)

    return assembly_line


def match_token(token):
    matched_token = None
    for token_type in all_token_types():
        if token_type.match(token)
            matched_token = token_type(token)
            break

    if matched_token is None:
        raise "Unable to match token"

    return matched_token


Should tokens that make up valid assembly be a pattern?
Means the assembly pattern needs to represent a signature

def match_tokens_to_pattern(tokens):
    if len(tokens) == 1:
        if isinstance(tokens[0], AnchorToken):
            return AnchorPattern(AnchorToken)





Keep assembly and instruction definitions as seperate as possible.

The single point of commonality is a mapping to go from an assembly pattern to an
instruction signature (there's nothing saying multiple pattenrs can't
match the same signature)

Each assembly pattern needs to know how to ask for a machine code template
with appropriate placeholders for the constants that the assembler will fill in. We
Can't pass the thing that makes the templates the resolved constants because the
pattern that gets returned could change the constants (e.g. labels which need
to be word aligned)

Could be something like:

def get_microcode_template(instruction_signature, constants=None):
    pass

Or we make some room in the signature components (op code, arguments) to pass through a
key that allows us to do the constant replacement later. Maybe we could just pass the token?

So it would become something like:

def get_microcode_template(instruction_signature):
    pass

instruction_signature = (LOAD(), M_CONST("#123"), CONST("&label"))




















def build_chunks():
    chunks = []
    current_chunk = None
    for line in assembly_lines:
        if isinstance(line.pattern, Anchor):
            if current_chunk is not None:
                chunks.append(current_chunk)
            else:
                current_chunk = AssemblyChunk()
                current_chunk.start = line.pattern.anchor_value
        if isinstance(line.pattern, (Data, Assembly):
            current_chunk.append(line.pattern.to_machinecode_words())




def build_label_index():
    label_index = {}
    for chunk in machine_code_chunks:
        for word, word_index in in enumerate(chunk):
            if word.label is not None:
                label_index[word.label] = chunk.start_index + word_index


label_to_word_index = {
    "@start": 32,

}



Microcode definitions

Need to specify:
    Control step orders
    Flags for each step
    Control sigs at each step


LOAD M(CONST) A
    0
        EX CX NX ZX
            PC_OUT, MAR_IN
    1
        EX CX NX ZX
            RFM, ALU_IN, ALU_F_IS_A
    2
        EX CX NX ZX
            ALU_OUT, MAR IN
    3
        EX CX NX ZX
            RFM, A_IN


Might be able to write to MAR from RAM in this step, rather than using
ALU as an intermediate - seems suuuuper sketchy though.
Might need to add a Mirror MAR register?
LOAD M(CONST) A
    EX CX NX ZX
        PC.OUT, MAR.IN
        RFM, ALU.IN, ALU.A_IS_BUS, PC.COUNT
        ALU.OUT, MAR.IN
        RFM, A.IN

SKETCHYLOAD M(CONST) A
    EX CX NX ZX
        PC.OUT, MAR.IN
        RFM, MAR.IN
        RFM, A.IN









ADD M(CONST)
    EX CX NX ZX
        PC_OUT, MAR_IN
        RFM, ALU.A_PLUS_B, ALU.IN, PC.COUNT
        ALU.OUT, ACC.IN

JUMP_IF_ZERO_FLAG CONST
    EX CX NX ZL
        PC.COUNT
    EX CX NX ZH
        PC.OUT, MAR.IN
        RFM, PC.IN

JUMP_IF_ACC_EQ A CONST
    EL CX NX ZX
        A.OUT, ALU.A_IS_BUS, ALU.PASSTHRU, ALU.STORE_FLAGS
        PC.COUNT
    EH CX NX ZX
        A.OUT, ALU.A_IS_BUS, ALU.PASSTHRU, ALU.STORE_FLAGS
        PC.OUT, MAR.IN
        RFM, PC.IN

JUMP_IF_ACC_EQ M(CONST) CONST
    EL CX NX ZX
        PC_OUT, MAR_IN
        RFM, ALU.A_IS_BUS, ALU.PASSTHRU, ALU.STORE_FLAGS, PC.COUNT
        PC.COUNT
    EH CX NX ZX
        PC_OUT, MAR_IN
        RFM, ALU.A_IS_BUS, ALU.PASSTHRU, ALU.STORE_FLAGS
        PC.OUT, MAR.IN
        RFM, PC.IN





assembly
instructions
microcode

An instruction is a combination of an operation and arguments



Instructions (e.g. ADD A, ADD #42, ADD[$var]) are responisble for generating:
    microcode
    machinecode