Assembly
========

Assembly code provides a way to specify instructions for the computer to
perform in a more human readable from than machine code

Assembly operations and arguments to specify their behaviour can be saved in an
assembly file and passed to an assembler to convert them to machine code that
the computer can then execute.

These are the operations and other assembly constructs that can be used to
create a valid assembly file.

Arithmetic Operations
---------------------

ADD
^^^

The ``ADD`` operation adds the value held in the specified module (or a
constant) to the accumulator. The ALU flags generated by this operation are
stored.

The possible usages are:

 - ``ADD A``
 - ``ADD B``
 - ``ADD C``
 - ``ADD CONST``
 - ``ADD [CONST]``

SUB
^^^

The ``SUB`` operation subtracts the value held in the specified module (or a
constant) from the accumulator. The ALU flags generated by this operation are
stored.

The possible usages are:

 - ``SUB A``
 - ``SUB B``
 - ``SUB C``
 - ``SUB CONST``
 - ``SUB [CONST]``

INCR
^^^^

The ``INCR`` operation adds one to the given module or memory location. The
ALU flags generated by this operation are stored.

The possible usages are:

 - ``INCR ACC``
 - ``INCR A``
 - ``INCR B``
 - ``INCR C``
 - ``INCR [CONST]``

DECR
^^^^

The ``DECR`` operation subracts one from the given module or memory location.
The ALU flags generated by this operation are stored.

The possible usages are:

 - ``DECR ACC``
 - ``DECR A``
 - ``DECR B``
 - ``DECR C``
 - ``DECR [CONST]``

Data Operations
---------------

COPY
^^^^

The ``COPY`` operation copies the value from a source module to a destination
module. This overwrites the current value of the destination register. It
requires a single machine code byte in program memory.

It is used by specifying the source module as the first argument and the
destination module as the second.

The possible usages are:

 - ``COPY ACC A``
 - ``COPY ACC B``
 - ``COPY ACC C``
 - ``COPY ACC X``
 - ``COPY ACC Y``
 - ``COPY ACC Z``
 - ``COPY ACC SP``
 - ``COPY A ACC``
 - ``COPY A B``
 - ``COPY A C``
 - ``COPY B ACC``
 - ``COPY B A``
 - ``COPY B C``
 - ``COPY C ACC``
 - ``COPY C A``
 - ``COPY C B``
 - ``COPY X ACC``
 - ``COPY Y ACC``
 - ``COPY Z ACC``
 - ``COPY PC ACC``
 - ``COPY SP ACC``

LOAD
^^^^

The ``LOAD`` operation loads a value from data memory into a module.

It is used by specifying the position in memory as the first argument and the
destination module as the second. The position in memory can be a module or a
constant and is encased in square parentheses.

The possible usages are:

 - ``LOAD [ACC] A``
 - ``LOAD [ACC] B``
 - ``LOAD [ACC] C``
 - ``LOAD [A] ACC``
 - ``LOAD [A] B``
 - ``LOAD [A] C``
 - ``LOAD [B] ACC``
 - ``LOAD [B] A``
 - ``LOAD [B] C``
 - ``LOAD [C] ACC``
 - ``LOAD [C] A``
 - ``LOAD [C] B``
 - ``LOAD [SP] ACC``
 - ``LOAD [SP] A``
 - ``LOAD [SP] B``
 - ``LOAD [SP] C``
 - ``LOAD [CONST] ACC``
 - ``LOAD [CONST] A``
 - ``LOAD [CONST] B``
 - ``LOAD [CONST] C``

STORE
^^^^^

The ``STORE`` operation stores a value from a module in memory.

It is used by specifying the module as the first argument and the
location in memory as the second. The location in memory can be a module or a
constant and is encased in square parentheses.

The possible usages are:

 - ``STORE ACC [A]``
 - ``STORE ACC [B]``
 - ``STORE ACC [C]``
 - ``STORE ACC [SP]``
 - ``STORE ACC [CONST]``
 - ``STORE A [ACC]``
 - ``STORE A [B]``
 - ``STORE A [C]``
 - ``STORE A [SP]``
 - ``STORE A [CONST]``
 - ``STORE B [ACC]``
 - ``STORE B [A]``
 - ``STORE B [C]``
 - ``STORE B [SP]``
 - ``STORE B [CONST]``
 - ``STORE C [ACC]``
 - ``STORE C [A]``
 - ``STORE C [B]``
 - ``STORE C [SP]``
 - ``STORE C [CONST]``

PUSH and POP
^^^^^^^^^^^^

The ``PUSH`` and ``POP`` operations either:

 - Take the value in a module and copy it on top of the stack - making the
   stack bigger.
 - Take the value from the top of the stack and copying it to a
   module - making the stack smaller

The SP module is used to keep track of the top of the stack. The value in
SP points at the word currently at top of the stack. The stack
grows downwards in memory, i.e. as more values are added to the
stack, the value in SP gets smaller.

``PUSH`` first decrements SP, then stores the value in memory at the new
value of SP. ``POP`` copies the value in memory at SP to the given module,
then increments SP.

These operations no not alter the ALU flags.

The possible usages are:

 - ``PUSH ACC``
 - ``PUSH A``
 - ``PUSH B``
 - ``PUSH C``
 - ``POP ACC``
 - ``POP A``
 - ``POP B``
 - ``POP C``

SET
^^^

The ``SET`` operation will set a module or word in memory to a given
constant value.

It requires two machine code bytes in program memory. Consider the
:ref:`setzero` operation if the constant is zero.

The possible usages are:

 - ``SET ACC CONST``
 - ``SET A CONST``
 - ``SET B CONST``
 - ``SET C CONST``
 - ``SET SP CONST``
 - ``SET [CONST] CONST``

.. _setzero:

SET_ZERO
^^^^^^^^

The ``SET_ZERO`` operation will set a module to zero.

The ALU flags generated by this operation are not stored.

The possible usages are:

 - ``SET_ZERO ACC``
 - ``SET_ZERO A``
 - ``SET_ZERO B``
 - ``SET_ZERO C``

Program Control Operations
--------------------------

NOOP
^^^^

The ``NOOP`` does nothing - no module transfers occur on the bus for
one instruction cycle.

The possible usages are:

 - ``NOOP``

JUMP
^^^^

The ``JUMP`` operation will set the program counter to a value. The next
instruction to be executed will be the word in memory at the specifed
location in memory.

The possible usages are:

 - ``JUMP ACC``
 - ``JUMP A``
 - ``JUMP B``
 - ``JUMP C``
 - ``JUMP CONST``
 - ``JUMP [ACC]``
 - ``JUMP [A]``
 - ``JUMP [B]``
 - ``JUMP [C]``
 - ``JUMP [SP]``
 - ``JUMP [CONST]``

JUMP_IF_LT_ACC
^^^^^^^^^^^^^^

The ``JUMP_IF_LT_ACC`` operation will set the program counter (jump)
to the value of a given constant (second argument) if the value of the
first argument (module or constant or word in memory) is less than the
accumulator.

The instruction generates and stores (clobbers) the ALU flags.

The possible usages are:

 - ``JUMP_IF_LT_ACC A CONST``
 - ``JUMP_IF_LT_ACC B CONST``
 - ``JUMP_IF_LT_ACC C CONST``
 - ``JUMP_IF_LT_ACC CONST CONST``
 - ``JUMP_IF_LT_ACC [CONST] CONST``

JUMP_IF_LTE_ACC
^^^^^^^^^^^^^^^

The ``JUMP_IF_LTE_ACC`` operation will set the program counter (jump)
to the value of a given constant (second argument) if the value of the
first argument (module or constant or word in memory) is less than 
or equal to the accumulator.

The instruction generates and stores (clobbers) the ALU flags.

The possible usages are:

 - ``JUMP_IF_LTE_ACC A CONST``
 - ``JUMP_IF_LTE_ACC B CONST``
 - ``JUMP_IF_LTE_ACC C CONST``
 - ``JUMP_IF_LTE_ACC CONST CONST``
 - ``JUMP_IF_LTE_ACC [CONST] CONST``

JUMP_IF_ACC_EQ
^^^^^^^^^^^^^^

The ``JUMP_IF_ACC_EQ`` operation will set the program counter (jump)
to the value of a given constant (second argument) if the accumulator
is equal to the value of the first argument (module or constant).

The instruction generates and stores (clobbers) the ALU flags.

The possible usages are:

 - ``JUMP_IF_ACC_EQ A CONST``
 - ``JUMP_IF_ACC_EQ B CONST``
 - ``JUMP_IF_ACC_EQ C CONST``
 - ``JUMP_IF_ACC_EQ PC CONST``
 - ``JUMP_IF_ACC_EQ SP CONST``
 - ``JUMP_IF_ACC_EQ CONST CONST``


JUMP_IF_ACC_NEQ
^^^^^^^^^^^^^^^

The ``JUMP_IF_ACC_NEQ`` operation will set the program counter (jump)
to the value of a given constant (second argument) if the accumulator
is not equal to the value of the first argument (module or constant).

The instruction generates and stores (clobbers) the ALU flags.

The possible usages are:

 - ``JUMP_IF_ACC_NEQ A CONST``
 - ``JUMP_IF_ACC_NEQ B CONST``
 - ``JUMP_IF_ACC_NEQ C CONST``
 - ``JUMP_IF_ACC_NEQ PC CONST``
 - ``JUMP_IF_ACC_NEQ SP CONST``
 - ``JUMP_IF_ACC_NEQ CONST CONST``

JUMP_IF_GTE_ACC
^^^^^^^^^^^^^^^

The ``JUMP_IF_GTE_ACC`` operation will set the program counter (jump)
to the value of a given constant (second argument) if the value of the
first argument (module or constant) is greater than or equal to the
accumulator.

The instruction generates and stores (clobbers) the ALU flags.

The possible usages are:

 - ``JUMP_IF_GTE_ACC A CONST``
 - ``JUMP_IF_GTE_ACC B CONST``
 - ``JUMP_IF_GTE_ACC C CONST``
 - ``JUMP_IF_GTE_ACC PC CONST``
 - ``JUMP_IF_GTE_ACC SP CONST``
 - ``JUMP_IF_GTE_ACC CONST CONST``

JUMP_IF_GT_ACC
^^^^^^^^^^^^^^

The ``JUMP_IF_GT_ACC`` operation will set the program counter (jump)
to the value of a given constant (second argument) if the value of the
first argument (module or constant) is greater than the accumulator.

The instruction generates and stores (clobbers) the ALU flags.

The possible usages are:

 - ``JUMP_IF_GT_ACC A CONST``
 - ``JUMP_IF_GT_ACC B CONST``
 - ``JUMP_IF_GT_ACC C CONST``
 - ``JUMP_IF_GT_ACC PC CONST``
 - ``JUMP_IF_GT_ACC SP CONST``
 - ``JUMP_IF_GT_ACC CONST CONST``

JUMP_IF_EQ_ZERO
^^^^^^^^^^^^^^^

The ``JUMP_IF_EQ_ZERO`` operation will set the program counter (jump)
to the value of a given constant (second argument) if the value of the
first argument (a module) is equal to zero.

The instruction generates and stores (clobbers) the ALU flags.

The possible usages are:

 - ``JUMP_IF_EQ_ZERO ACC CONST``
 - ``JUMP_IF_EQ_ZERO A CONST``
 - ``JUMP_IF_EQ_ZERO B CONST``
 - ``JUMP_IF_EQ_ZERO C CONST``
 - ``JUMP_IF_EQ_ZERO PC CONST``
 - ``JUMP_IF_EQ_ZERO SP CONST``


JUMP_IF_NEQ_ZERO
^^^^^^^^^^^^^^^^

The ``JUMP_IF_NEQ_ZERO`` operation will set the program counter (jump)
to the value of a given constant (second argument) if the value of the
first argument (a module) is not equal to zero.

The instruction generates and stores (clobbers) the ALU flags.

The possible usages are:

 - ``JUMP_IF_NEQ_ZERO ACC CONST``
 - ``JUMP_IF_NEQ_ZERO A CONST``
 - ``JUMP_IF_NEQ_ZERO B CONST``
 - ``JUMP_IF_NEQ_ZERO C CONST``
 - ``JUMP_IF_NEQ_ZERO PC CONST``
 - ``JUMP_IF_NEQ_ZERO SP CONST``


JUMP_IF_POSITIVE_FLAG
^^^^^^^^^^^^^^^^^^^^^

The ``JUMP_IF_POSITIVE_FLAG`` operation will set the program counter to the
value of a given constant if the last operation that the ALU flags were
stored for resulted in a positive value (when read as 2's compliment).

The possible usages are:

 - ``JUMP_IF_POSITIVE_FLAG CONST``

JUMP_IF_NEGATIVE_FLAG
^^^^^^^^^^^^^^^^^^^^^

The ``JUMP_IF_NEGATIVE_FLAG`` operation will set the program counter to the
value of a given constant if the last operation that the ALU flags were
stored for resulted in a negative value (when read as 2's compliment).

The possible usages are:

 - ``JUMP_IF_NEGATIVE_FLAG CONST``

JUMP_IF_OVERFLOW_FLAG
^^^^^^^^^^^^^^^^^^^^^

The ``JUMP_IF_OVERFLOW_FLAG`` operation will set the program counter to the
value of a given constant if the last operation that the ALU flags were
stored for resulted in an overflow.

The possible usages are:

 - ``JUMP_IF_OVERFLOW_FLAG CONST``

JUMP_IF_NOT_OVERFLOW_FLAG
^^^^^^^^^^^^^^^^^^^^^^^^^

The ``JUMP_IF_OVERFLOW_FLAG`` operation will set the program counter to the
value of a given constant if the last operation that the ALU flags were
stored for did not result in an overflow.

The possible usages are:

 - ``JUMP_IF_NOT_OVERFLOW_FLAG CONST``

JUMP_IF_UNDERFLOW_FLAG
^^^^^^^^^^^^^^^^^^^^^^

The ``JUMP_IF_UNDERFLOW_FLAG`` operation will set the program counter to the
value of a given constant if the last operation that the ALU flags were
stored for resulted in an underflow.

The possible usages are:

 - ``JUMP_IF_UNDERFLOW_FLAG CONST``

JUMP_IF_NOT_UNDERFLOW_FLAG
^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``JUMP_IF_NOT_UNDERFLOW_FLAG`` operation will set the program counter to the
value of a given constant if the last operation that the ALU flags were
stored for did not result in an underflow.

The possible usages are:

 - ``JUMP_IF_NOT_UNDERFLOW_FLAG CONST``

JUMP_IF_ZERO_FLAG
^^^^^^^^^^^^^^^^^

The ``JUMP_IF_ZERO_FLAG`` operation will set the program counter to the
value of a given constant if the last operation that the ALU flags were
stored for resulted in an answer of zero.

The possible usages are:

 - ``JUMP_IF_ZERO_FLAG CONST``

JUMP_IF_NOT_ZERO_FLAG
^^^^^^^^^^^^^^^^^^^^^

The ``JUMP_IF_NOT_ZERO_FLAG`` operation will set the program counter to the
value of a given constant if the last operation that the ALU flags were
stored for resulted in a non zero answer.

The possible usages are:

 - ``JUMP_IF_NOT_ZERO_FLAG CONST``

CALL
^^^^

The ``CALL`` operation will push the current program counter (i.e. the next
instruction to be executed) onto the stack, then set the program counter (
i.e. jump) to the value in the given module or constant.

The possible usages are:

 - ``CALL ACC``
 - ``CALL A``
 - ``CALL B``
 - ``CALL C``
 - ``CALL CONST``

RETURN
^^^^^^

The ``RETURN`` operation will pop the top of the stack into the program counter.

It expects to be used after having arrived at a section of assembly with the
``CALL`` instruction.

The possible usages are:

 - ``RETURN``

HALT
^^^^

The ``HALT`` operation halts execution of the computer by stopping the clock.

The possible usages are:

 - ``HALT``

Logical Operations
------------------

NOT
^^^

The ``NOT`` operation inverts all the bits of the specified module in place.
The ALU flags generated by this operation are stored.

The possible usages are:

 - ``NOT ACC``
 - ``NOT A``
 - ``NOT B``
 - ``NOT C``
 - ``NOT [CONST]``


AND
^^^

The ``AND`` operation performs a logical AND with the value held in the
specified module (or a constant) and the accumulator. The result is stored in
the accumulator. The ALU flags generated by this operation are stored.

The possible usages are:

 - ``AND A``
 - ``AND B``
 - ``AND C``
 - ``AND CONST``
 - ``AND [CONST]``

NAND
^^^^

The ``NAND`` operation performs a logical NAND with the value held in the
specified module (or a constant) and the accumulator. The result is stored in
the accumulator. The ALU flags generated by this operation are stored.

The possible usages are:

 - ``NAND A``
 - ``NAND B``
 - ``NAND C``
 - ``NAND CONST``
 - ``NAND [CONST]``

OR
^^

The ``OR`` operation performs a logical OR with the value held in the
specified module (or a constant) and the accumulator. The result is stored in
the accumulator. The ALU flags generated by this operation are stored.

The possible usages are:

 - ``OR A``
 - ``OR B``
 - ``OR C``
 - ``OR CONST``
 - ``[OR CONST]``

NOR
^^^

The ``NOR`` operation performs a logical NOR with the value held in the
specified module (or a constant) and the accumulator. The result is stored in
the accumulator. The ALU flags generated by this operation are stored.

The possible usages are:

 - ``NOR A``
 - ``NOR B``
 - ``NOR C``
 - ``NOR CONST``
 - ``NOR [CONST]``

XOR
^^^

The ``XOR`` operation performs a logical XOR with the value held in the
specified module (or a constant) and the accumulator. The result is stored in
the accumulator. The ALU flags generated by this operation are stored.

The possible usages are:

 - ``XOR A``
 - ``XOR B``
 - ``XOR C``
 - ``XOR CONST``
 - ``XOR [CONST]``

NXOR
^^^^

The ``NXOR`` operation performs a logical NXOR (an XOR, then inverted) with
the value held in the specified module (or a constant) and the accumulator.
The result is stored in the accumulator. The ALU flags generated by this
operation are stored.

The possible usages are:

 - ``NXOR A``
 - ``NXOR B``
 - ``NXOR C``
 - ``NXOR CONST``
 - ``NXOR [CONST]``

Miscellaneous Operations
------------------------

ROT_LEFT
^^^^^^^^

The ``ROT_LEFT`` operation rotates all the bits in the specifed
module or memory location to the left (most significant side). All
the bits move one place to the left, and the most significant bit
becomes the least significant.

If the most significant bit prior to the operation was a 1 the carry flag is
set.

The possible usages are:

 - ``ROT_LEFT ACC``
 - ``ROT_LEFT A``
 - ``ROT_LEFT B``
 - ``ROT_LEFT C``
 - ``ROT_LEFT [CONST]``

ROT_RIGHT
^^^^^^^^

The ``ROT_RIGHT`` operation rotates all the bits in the specifed
module or memory location to the right (least significant side). All the bits
move one place to the right, and the least significant bit becomes the most
significant bit.

If the least significant bit prior to the operation was a 1 the carry flag is
set.

The possible usages are:

 - ``ROT_RIGHT ACC``
 - ``ROT_RIGHT A``
 - ``ROT_RIGHT B``
 - ``ROT_RIGHT C``
 - ``ROT_RIGHT [CONST]``


SHIFT_LEFT
^^^^^^^^

The ``SHIFT_LEFT`` operation shifts all the bits in the specifed
module or memory location one place to the left (most significant side).

If the most significant bit prior to the operation was a 1 the carry flag is
set.

The possible usages are:

 - ``SHIFT_LEFT ACC``
 - ``SHIFT_LEFT A``
 - ``SHIFT_LEFT B``
 - ``SHIFT_LEFT C``
 - ``SHIFT_LEFT [CONST]``

SHIFT_RIGHT
^^^^^^^^

The ``SHIFT_RIGHT`` operation shifts all the bits in the specifed
module or memory location one place to the right (least significant side).

If the least significant bit prior to the operation was a 1 the carry flag is
set.

The possible usages are:

 - ``SHIFT_RIGHT ACC``
 - ``SHIFT_RIGHT A``
 - ``SHIFT_RIGHT B``
 - ``SHIFT_RIGHT C``
 - ``SHIFT_RIGHT [CONST]``


Constants
---------

Constants are values that the assembler will convert to machine code bytes for
operations that require data in the machine code. For example, a jump to an
explicit index in program memory, or setting a register to an explicit value.

There are 3 kinds of constants: labels, variables and numbers.

Labels
^^^^^^

A label binds to the line of assembly that follows it. Once assembly is complete
the label's value is the index in program memory of the instruction byte that
followed the label definition. E.g. If an assembly file looked like this:

.. code-block:: text

        LOAD [#123] A
        ADD A

    @label
        SET B #42

The value of ``@label`` would be 3. The instruction byte corresponding to
``SET B #42`` is at program memory index 3. ``LOAD [#123] A`` takes 2 bytes,
``ADD A`` one, and ``SET B #42`` is the byte after that.

Labels are typically used by jump operations.

A label is a token that starts with the ``@`` character followed by any letter or
an underscore, then any alphanumeric or an underscore. E.g.:

 - ``@label``
 - ``@label_1``
 - ``@_other_label``
   
Labels must be unique.

A label is defined by putting it on a line by itself.

Variables
^^^^^^^^^

Variables are named aliases for indexes into data memory. They can be
predeclared by putting them by themselves on a line or declared as they are
used by using them as an argument.

The index for a given variable is determined by the assembler. As it parses
assembly lines from the start of the file to the end, addresses are assigned to
variables as they are encountered in the file. E.g. for the following assembly:

.. code-block:: text

        $variable1
        COPY A ACC
        LOAD [$variable2] A

variable1 is predeclared, variable2 is declared as it's used. Once assembled,
variable1 is an alias for 0, variable2 is an alias for 1.

A variable is a token that starts with the ``$`` character followed by any letter or
an underscore, then any alphanumeric or an underscore. E.g.:

 - ``$variable``
 - ``$variable1``
 - ``$_other_variable``

Numbers
^^^^^^^

Numbers are integer values. In most cases they within the range -127 to 255
(inclusive). This range comes from the minimum and maximum values that 8 bits,
or 8 bits with 2's compliment encoding can hold.

A number is a token that starts with the ``#`` character and is followed by any
valid Python integer definition. E.g. 

 - ``#123`` (decimal)
 - ``#-5`` (decimal)
 - ``#0b00010010`` (binary)
 - ``#-0b0101`` (binary)
 - ``#0xA2`` (hex)
 - ``#0o107`` (octal)

Comments
--------

Comments are parts of the assembly file ignored by the assembler.

A comment is anything after and including ``//`` on a line until the end of the
line.















